### C언어

---

#### C언어의 특징

* 저급언어 특징 + 고급언어 특징
* 절차지향적 언어
* 구조적 프로그래밍 방식
* 호환성이 높은 언어


#### 실행파일이 되기까지 과정

###### `전처리기 -> 컴파일러 -> 링커 -> 실행파일 생성`

* 전처리기 : 소스 내의 #이 붙은 전처리문을 처리해줍니다.
* 컴파일러 : C언어를 기계어로 변환 해 줍니다 이과정에서 'obj' 파일 생성
* 링커 : 'obj' 파일을 연결시켜주는 작업을 해줍니다.



#### 1. 기본구성

~~~
#include <stdio.h>

void main()
{
	// 선언부
	
    printf("Hello world!\n"); //구현부
}
~~~

* #include <stdio.h> 는

  stdio.h 헤더파일을 포함시키겠다 라는 뜻!

  여기서 #을 이용한 것은 전처리를 시키겠다는 뜻입니다.

* C프로그램의 구조는 기본적으로 선언부와 구현부로 되어있으며, 중괄호 기준으로 윗부분은 선언부 아랫부분은 구현부로 되어있습니다.

  > 컴파일러나 컴파일러의 버전에 따라 엄격하게 지키지 않아도 됩니다.



#### 2. 자료형

* 정수형 : 양수 와 0 음수

  | 자료형 |  크기  |          표현범위           |
  | :----: | :----: | :-------------------------: |
  | short  | 2 byte |      -32,768 ~ 32,767       |
  |  int   | 4 byte | -21억5천~ 21억5천 = 약 43억 |
  |  long  | 4 byte | -21억5천~ 21억5천 = 약 43억 |

  * 앞에 **unsigned** 를 붙이면 양의 정수만 사용한다는 뜻!
    따라서 unsigned short 같은 경우는 + 65534 가 됩니다.
  * **signed** 는 보통 생략되어 있습니다.




* 실수형 : 소수점이 있는 자릿수

  | 자료형 |  크기  | 유효 자릿수 |
  | :----: | :----: | :---------: |
  | float  | 4 byte |      7      |
  | double | 8 byte |     15      |

  * 유효 자릿수를 넘어가면 뒷부분은 쓰레기값으로 채워집니다.

* 문자형

  | 자료형 |  크기  |  표현범위  |
  | :----: | :----: | :--------: |
  |  char  | 1 byte | -128 ~ 127 |

  * 숫자를 직접 저장할 수도 있고, 문자를 넣을 수 있다!
    문자의 경우 들어갈 땐 아스키코드상 숫자로 입력되고 꺼낼 땐 아스키코드상 문자로 출력됩니다.
  * unsigned char 경우 확장아스키코드 등을 사용할 경우입니다.



#### 3. 연산자

* 대입연산자

  ~~~
  a = 1    // 오른쪽 값 1을 a에 집어넣는다.
  ~~~

* 산술연산자

  : +, -, *, /, %

  ~~~
  a = 1+2   // 1과 2를 더한다.
  b = 2-1   // 2에서 1를 뺀다.
  c = 1*2   // 1과 2를 곱한다.
  d = 4/2   // 4를 2로 나눈 값.
  e = 4/3   // 4와 3을 나눈 나머지 값.
  
  ~을 각 알파벳에 대입한다!
  ~~~



* 증감연산자
  : ++ , --

  ~~~
  ++a , ++b   // 전위증감연산자
  a-- , b--   // 후위증감연산자
  ~~~

  * <u>전위증감연산자</u>는 증감연산자처리를 먼저 한 후 그 행이 처리되고
    <u>후위증감연산자</u>는 그 행이 처리 된 후 증감연산자 처리를 한다.



* 논리연산자
  : &&, ||, !

  ~~~
  A && B      // A 와 B가 모두 1일때 1 
  A || B      // A 와 B중 하나 이상이 1일때 1
  A= !B       // A가 B는 무조건 반대
  ~~~



* 삼항연산자
  ` 조건? 참일때 값 : 거짓일 때 값;`

  ~~~
  int x = 10;
  int y = 20;
  int z = 30;
  
  
  z = (x > y) ?  1 : 2;    // x > y 가 거짓임으로  z = 2
  
  z = (x == 10) ? 1 : 2;   // x = 10 이 참이므로   z = 1
  
  ~~~



* 비트연산자
  : &, |, ~, ^, <<, >>

  ~~~
  a = 1010 0101;
  b = 1001 1001;
   
  
  c = a & b;    // c = 1000 0001
  
  c = a | b;    // c = 1011 1101
  
  c = ~a;       // c = 0101 1010
  
  c = a^b;      // c = 0011 1100
  
  //쉬프트연산자
  
  c = a << 1;    // c = 0111 0100
  
  c = a << 2;    // c = 1110 1000
  
  c = a >> 1;    // c = 0001 1101
  
  c = a >> 2;    // c = 0000 1110
  ~~~



#### 4. 출력문

|              종류               |              뜻               |
| :-----------------------------: | :---------------------------: |
| printf("문자열 형식", 값, ..값) | 화면에 출력하고 싶은 함수형태 |
|               \n                |       키보드 Enter 기능       |
|               \r                |  같은 줄의 맨 처음으로 이동   |
|               \t                |        키보드 Tab 기능        |

* 문자열 형식

  | 서식문자 |     기능      |
  | :------: | :-----------: |
  |    %d    |  short, int   |
  |   %ld    |     long      |
  |    %f    | float. double |
  |    %c    |  char (단일)  |
  |    %s    | char[] 문자열 |
  |    %x    |    16진수     |
  |    %p    |  & 주소출력   |



#### 5. 입력문

* getchar()
  : 단일 문자를 입력받습니다.

  ~~~
  형태 : int getchar
  
  사용법:
  char a;
  a = getchar();
  ~~~

* gets()

  : 엔터키를 입력할 때 까지의 문자열을 입력받습니다.

  ~~~
  형태 : gets(문자열을 입력받을 변수);
  
  사용법:
  char str[50];
  gets(str);
  
  but! 변수크기에 벗어나면 에러가 발생합니다
  
  그래서
  
  gets_s(입력받을 문자열 변수,입력받을 변수 크기)
  gets_s(str,90)
  ~~~

* scanf()
  : 여러개의 변수를 한번에 입력받습니다.

  ~~~
  형태 : scanf("입력받을 문자열 형태", 입력받을 변수주소);
  
  사용법:
  int a;
  scanf("%d", &a);
  ~~~




#### 6. 조건문

* if 문

  ~~~
  if (조건1)
  { 
  
  // 조건1이 만족할때 실행할 코드
  
  }
  
  else if (조건2)
  
  {
  
  // 조건2가 만족할때 실행할 코드
  
  }
  
  else
  
  {
  
  // 조건2가 만족하지 않을때 실행할 코드
  
  }
  ~~~

* switch 문

  ~~~
  switch(변수)
  {
  
  case 값1:
  
  {
  
  // 값1일때 실행할 코드
  
  }
  
  break;
  
   
  
  case 값2:
  
  {
  
  // 값2일때 실행할 코드
  
  }
  
  break;
  
   
  
  default:
  
  {
  
  // 위의 조건을 만족하지 않을때 실행할 코드
  
  }
  
  }
  ~~~



#### 7. 반복문

* while 문

  : 특정조건에 맞는 반복작업이 필요할 때 사용합니다.

  ~~~
  while(조건)
  {
  
  반복 작업할 코드
  
  }
  ~~~

* do while 문

  : 무조껀 한번 이상 반드시 실행되어야 할 때 사용합니다.

  ~~~
  do
  {
  
  반복 작업할 코드
  
  } while (조건);
  ~~~

* for 문

  : 정해진 횟수만큼 반복작업이 필요할 때 사용합니다.

  ~~~
  for (변수의 초기값; 조건; 변수의 연산)
  {
  
  반복 작업할 코드
  
  }
  ~~~

* 무한루프

  : 빠져 나오지 않고 계속 반복문이 도는 무한루프를 설정할 때 사용합니다.

  ~~~
  while (1)
  {
  
  } 
  
  
  do
  {
  
  } while (1);
  
   
  
  for (;;)
  {
  
  }
  ~~~



#### 8. 제어문

* break 문

  : 지금 처리하고 있는 블럭문을 빠져나간 후 그 다음 문장을 실행합니다.

  ~~~
  int a;
   
  
  switch (a)
  {
  case 1:
  
  printf("안녕하세요!.\n");
  break;
  
  
  case 2:
  
  printf("반갑습니다!.\n");
  break;
  }
  ~~~

  ~~~int a;
  int a;
   
  for (a = 1; a <= 10; a++)
  
  {
  
  if ( a > 5)
  
  break;
  
  printf("a = %d\n", a);
  
  }
  
  
  실행결과
  
  a = 1
  a = 2
  a = 3
  a = 4
  a = 5
  ~~~

* continue 문

  : 반복문 안에서 사용되며 반복문의 조건을 판단하는 줄로 바로 이동합니다.

  ~~~
  int a;
   
  
  for (a = 1; a <= 10; a++)
  
  {
  
  if ((a % 2) == 1)
  
  continue;      // 이 구문을 만나면 다시 for문으로 올라갑니다.
  
  printf("a = %d\n", a);
  
  }
  
  
  실행결과
  
  a = 1
  a = 2
  a = 3
  a = 4
  a = 5
  ~~~



* return 문

  : 해당 함수를 바로 빠져나가게 됩니다.

  ~~~
  void main()
  {
  
  int a;
  
  
  for (a = 1; a <= 10; a++)
  
  {
  
  if (a > 5)
  
  return;
  
  
  printf("a = %d\n", a);
  
  }
  
  printf("---출력 완료---\n");
  
  } 
  
  
  실행 결과
  
  a = 1
  a = 2
  a = 3
  a = 4
  a = 5 
  ~~~



* goto 문

  : 프로그래머가 지정한 줄로 이동합니다.
  : goto문은 프로그램의 흐름을 임의로 변경하는 것이기 때문에 가끔적 사용을 자제해야합니다.

  ~~~
  int a;
   
  
  for (a = 1; a <= 10; a++)
  
  {
  
  if (a > 5)
  
  goto abc;
  
   
  printf("a = %d\n", a);
  
  } 
  
  abc: 
   
   
  실행 결과
  
  a = 1
  a = 2
  a = 3
  a = 4
  a = 5
  ~~~



#### 9. 배열

* 배열의 선언과 초기화

  ~~~
  선언
  : 자료형 변수이름[갯수];
  
  초기화
  : int a[3] = {1,2,3};
  
  
  ! 선언 따로 초기화 따로는 안됩니다.
  
  int a[3];
  a = {1,2,3} ;
  
  
  ! 배열선언후 남은공간은 쓰레기값으로 채워집니다.
  
  int a[5] = {1,2,3};
  
  
  ! 초기화할 때 갯수를 지정하지 않을수 있습니다.
    이럴경우 초기화 된 갯수만큼 자동으로 크기를 가지게 됩니다.
    
  int a[] = {1,2,3,4,5};
  ~~~

* 배열의 사용

  ~~~
  int a[5] = {1, 2, 3, 4, 5};
  int i = 0;
  
  for (i = 0; i < 5; i++)
  
  printf("%d\n", a[i]);
  
   
  실행 결과
  
  1
  2
  3
  4
  5
  ~~~



#### 10. 포인터

* 포인터변수

  ~~~
  형태 : 자료형 *변수명;
  ex)
  int a = 0;        // 일반 변수
  int *p = NULL;    // 포인터 변수
  ~~~

* 포인터연산자

  ~~~
  int a = 0;
  int *p1 = &a;        // p1에 a의 주소를 저장
  
  int *p2;             // a의 주소를 저장하려고 한다.
  
  p2 = &p1;            // p2에 p1의 주소를 저장 (X)
  
  p2 = p1;             // p2에 p1의 값인 a의 주소를 저장 (O)
  ~~~

* 다중포인터
  : 포인터의 주소를 가르킵니다. 이중, 더블포인터라고도 합니다.

  ~~~
  int a = 1;
  int *p1 = &a;
  int **p2 = &p1;
  
  *(*p2) = 123;
  
  printf("%d", *(*p2));
  
   
  실행 결과
  
  123
  ~~~

* 1차원 배열과 포인터

  ~~~
  char str[5] = {'a', 'b', 'c'};
  char *p = str;
  
  int i = 0;
  
  for (i = 0; i < 5; i++)
  
  printf("%c", p[i]);
  
   
  실행 결과
  
  abc
  
  ~~~

  * 배열자체가 포인터이기 때문에 포인터 변수 p에 바로 대입가능하며 
    포인터변수 p를 마치 배열처럼 사용할 수 있습니다.

* 포인터 연산

  ~~~
  char str[5] = "abc";
  
  char *p = str;            // 대입연산
  
  p = p + 1;                 // 산술연산
  
  p++;                        // 증감연산
  
  p += 1;                    // 할당연산
  
  if (p == NULL)          // 관계연산
  ~~~

  * p+1 이라고 해서 주소값에 1을 더하는게 아니라 주소의 자료형만큼 1개 증가시킨다는 뜻입니다.(int 같은경우는 4개 증가)

* 포인터배열
  : 포인터로 되어있는 배열

  ~~~
  int a = 1, b = 2, c = 3;
  int *p[3] = {&a, &b, &c};
  
  *p[0] = 123;
  *p[1] = 456;
  *p[2] = 789;
  
  printf("%d %d %d\n", a, b, c);
  printf("%d %d %d\n", *p[0], *p[1], *p[2]);
  
  
  실행 결과
  
  123 456 789
  
  123 456 789
  ~~~

* 다차원 배열과 배열 포인터

  ~~~
  int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12}; 
  int *p = a;               // 컴파일 에러
  int (*q)[4] = a;	      // 일치
  int **r = a;              // 컴파일 에러
  
  여기서
  a = &a[0]        // 배열의 이름은 배열의 시작주소를 가리킵니다.
  
  
  왜 두번째만 컴파일 에러가 안날까요?
  int a[3][4] 일 때 배열명 a는 &a[0]의 주소인데, a[0]은 a배열의 첫 요소 즉, 3칸 짜리 배열에는 int [4] 즉, int 4개 짜리 배열이 들어 있으므로 a[0]는 그 속의 int [4] 배열의 이름이 됩니다.
  
  
  배열 포인터 예시
  
  int a[3];
  int *pa = a;
  
  int b[4][3];
  int (*pb)[3] = b;
  
  int c[5][4][3];
  int (*pc)[4][3];
  ~~~



#### 11. 메모리 할당

* 정적 메모리 할당

  : 처음부터 정해진 공간을 할당받고 변수가 소멸할 때까지 이 공간의 크기를 바꾸지 못합니다.

  ~~~
  int a;
  char str[10];
  
  int score[20][20];
  ~~~

  * 선언과 동시에 크기가 정해지며 도중에 바꿀 수 없습니다.
  * 할당된 메모리를 자동으로 운영체제가 회수합니다.
  * 메모리를 낭비하는 경우가 많습니다.



* 동적 메모리 할당

  * 포인터의 변수를 선언시 임의의 공간을 할당받고 다 쓴 메모리를 해제하여 운영체제에게 돌려줍니다.

  * 동적 메모리 할당방법

    * 동적메모리 헤더파일

      ~~~
      #include <stdlib.h>
      ~~~

    * 동적메모리 형식

      ~~~
      포인터를 받을 변수 = (자료형) malloc(할당받을 바이트 수)
      ex)  str = (char*) malloc(20);
      ~~~

      * **여기서 자료형은 포인터를 받을 변수와 일치해야합니다***

      * **사용을 한 후 반드시 메모리 해제를 해야합니다**

        ~~~
        free(str);    // 메모리해제
        ~~~

  * 사용 예시

    ~~~
    int *p = (int*) malloc(sizeof(int) * 3);
     
    p[0] = 1;
    p[1] = 2;
    p[2] = 3;
    
    printf("%d\t%d\t%d\n", p[0], p[1], p[2]);
    
    free(p);
    ~~~

    * malloc() 에서 ()안에는 바이트 수가 들어가는데 주로 sizeof()연산자를 사용한다.



#### 12. 유용한 문자열 함수들

* 대문자변환

  ~~~
  strlwr()
  ~~~

* 소문자변환

  ~~~
  strupr()
  ~~~

* 문자, 문자열 검색

  ~~~
  찾은 위치의 포인터 = strchr(문자열, 찾을 문자);
  
  예)
  
  char str[80] = "abcde 12345";
  char *p = strchr(str, 'e');
  
  if (p)
  
  printf("%s\n", p);
  
  
  실행 결과
  
  e 12345
  ~~~



#### 13. 함수의 선언과 구성요소

* 형태

  ~~~
  반환값 함수명(인자, 인자 ...)
  {
  
  코드들...
  
  }
  
  사용예시 :
  
  #include <stdio.h>
   
  
  int sum(int a, int b)
  
  {
  
  int c = a + b;
  
  return c;
  
  }
  
   
  
  void main()
  
  {
  
  int num1 = 3, num2 = 5;
  
  int total = sum(num1, num2);
  
   
  printf("%d\n", total);
  
  }
  ~~~

  * 함수를 사용하기 위해선 메인 함수보다 위에 선언 해야 합니다.

    하지만 메인 함수보다 아래에 사용해야 할 경우 아래 처럼 함수의 원형을 선언해줘야 합니다.

  ~~~
  #include <stdio.h>
  
   
  int sum(int a, int b);            // 함수의 원형
  
  
  void main()
  {
  
  int num1 = 3, num2 = 5;
  
  int total = sum(num1, num2);
  
  printf("%d\n", total);
  
  }
  
  
  int sum(int a, int b)
  {
  
  int c = a + b;
  
  return c;
  
  }
  ~~~



#### 14. 변수의 종류

* 지역변수

  : 블럭안에서 선언된 변수로써, 함수가 끝날 시 소멸됩니다. 
    선언시 초기값은 어떤 값인지 모른다.

* 전역변수
  : 블럭밖에서 선언하여 전체 함수에서 사용할 수 있습니다.
    프로그램이 종료될 때 사라지며, 선언시 초기값은 0 입니다.

* 정적변수

  * 형태

    ~~~
    static 자료형 변수명;
    ~~~

  * 특징
    : 블럭이 끝나도 사라지지 않는다. 초기값은 0으로 초기화된다.
      블럭밖에서 이 변수를 사용할 수 없다.

* 외부변수
  : extern

  * 특정한 전역변수를 다른 파일에서도 사용할 수 있게 해줍니다.



#### 15. 구조체

* 형태

  ~~~
  struct 구조체이름
  {
  자료형 변수명;
  자료형 변수명;
  ...
  }
  
  예시)
  
  struct score
  {
  
  int scoreKOR;
  int scoreMAT;
  int scoreENG;
  int scoreSCI;
  
  }
  
  void main()
  
  {
  
  struct score a;
  
  }
  ~~~




